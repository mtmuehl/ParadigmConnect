pragma solidity ^0.4.24;

import "./Token.sol";
import "paradigm-solidity/contracts/SubContract.sol";
import "paradigm-solidity/contracts/SignatureVerification.sol";

contract BasicTradeSubContract is SubContract, SignatureVerification {

    mapping(bytes32 => uint) bought;

    constructor(string _makerArguments, string _takerArguments) {
        makerArguments = _makerArguments;
        takerArguments = _takerArguments;
    }

    function participate(bytes32[] makerData, bytes32[] takerData) public returns (bool) {
      // 1. Standard validation
      require(verify(makerData));

      // 2. Contract specific validation
      uint signerTokenCount = uint(makerData[2]);
      uint signerTokenCountToTake = uint(takerData[0]);
        require(bought[getOrderHash(makerData)] + signerTokenCountToTake <= signerTokenCount);

        // transfer maker -> taker
        require(sendFromMaker(makerData, takerData));
        // transfer taker -> maker
        require(sendFromTaker(makerData, takerData));
        bought[getOrderHash(makerData)] = bought[getOrderHash(makerData)] + signerTokenCountToTake;

      return true;
    }

    function getOrderHash(bytes32[] makerData) returns (bytes32) {
      address signerToken = address(makerData[1]);
      uint signerTokenCount = uint(makerData[2]);
      address buyerToken = address(makerData[3]);
      uint buyerTokenCount = uint(makerData[4]);
      return keccak256(getSigner(makerData), signerToken, signerTokenCount, buyerToken, buyerTokenCount);
    }

    function sendFromMaker(bytes32[] makerData, bytes32[] takerData) returns (bool) {
//        TODO: Shouldn't use tx.origin?
        return Token(address(makerData[1])).transferFrom(address(makerData[0]), address(tx.origin), uint(takerData[0]));
    }

    function sendFromTaker(bytes32[] makerData, bytes32[] takerData) returns (bool) {
        uint tokensTakerCount = ratioFor(uint(makerData[4]), uint(takerData[0]), uint(makerData[2]));


        return Token(address(makerData[3])).transferFrom(address(tx.origin), address(makerData[0]), tokensTakerCount);
    }
}
